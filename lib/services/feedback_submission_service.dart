import 'package:flutter/foundation.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/feedback_submission_model.dart';

class FeedbackSubmissionService extends ChangeNotifier {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  
  List<FeedbackSubmission> _submissions = [];
  bool _isLoading = false;
  String _searchQuery = '';
  FeedbackStatus? _selectedStatus;
  String? _selectedType;

  List<FeedbackSubmission> get submissions => _submissions;
  bool get isLoading => _isLoading;
  String get searchQuery => _searchQuery;
  FeedbackStatus? get selectedStatus => _selectedStatus;
  String? get selectedType => _selectedType;

  Future<void> loadSubmissions() async {
    _isLoading = true;
    notifyListeners();

    try {
      final querySnapshot = await _firestore
          .collection('feedback_submissions')
          .orderBy('submittedAt', descending: true)
          .get();

      _submissions = querySnapshot.docs
          .map((doc) => FeedbackSubmission.fromFirestore(doc))
          .toList();

      debugPrint('Loaded ${_submissions.length} feedback submissions');
    } catch (e) {
      debugPrint('Error loading feedback submissions: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<String> submitFeedback({
    String? name,
    String? email,
    required String subject,
    required String message,
    required String feedbackType,
    required int rating,
  }) async {
    try {
      final submission = FeedbackSubmission(
        id: '', // Will be generated by Firestore
        name: name,
        email: email,
        subject: subject,
        message: message,
        feedbackType: feedbackType,
        rating: rating,
        submittedAt: DateTime.now(),
      );

      final docRef = await _firestore
          .collection('feedback_submissions')
          .add(submission.toFirestore());

      debugPrint('Feedback submitted with ID: ${docRef.id}');
      await loadSubmissions(); // Refresh the list
      return docRef.id;
    } catch (e) {
      debugPrint('Error submitting feedback: $e');
      rethrow;
    }
  }

  Future<void> updateSubmissionStatus(
    String submissionId,
    FeedbackStatus status, {
    String? adminResponse,
    String? respondedBy,
  }) async {
    try {
      final updates = {
        'status': status.toString().split('.').last,
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      };

      if (adminResponse != null) {
        updates['adminResponse'] = adminResponse;
      }

      if (respondedBy != null) {
        updates['respondedBy'] = respondedBy;
        if (status == FeedbackStatus.acknowledged || status == FeedbackStatus.closed) {
          updates['respondedAt'] = Timestamp.fromDate(DateTime.now());
        }
      }

      await _firestore
          .collection('feedback_submissions')
          .doc(submissionId)
          .update(updates);

      debugPrint('Feedback submission $submissionId status updated to $status');
      await loadSubmissions(); // Refresh the list
    } catch (e) {
      debugPrint('Error updating feedback submission status: $e');
      rethrow;
    }
  }

  void searchSubmissions(String query) {
    _searchQuery = query.toLowerCase();
    notifyListeners();
  }

  void filterByStatus(FeedbackStatus? status) {
    _selectedStatus = status;
    notifyListeners();
  }

  void filterByType(String? type) {
    _selectedType = type;
    notifyListeners();
  }

  List<FeedbackSubmission> get filteredSubmissions {
    List<FeedbackSubmission> filtered = List.from(_submissions);

    // Apply search filter
    if (_searchQuery.isNotEmpty) {
      filtered = filtered.where((submission) {
        return (submission.name?.toLowerCase().contains(_searchQuery) ?? false) ||
               (submission.email?.toLowerCase().contains(_searchQuery) ?? false) ||
               submission.subject.toLowerCase().contains(_searchQuery) ||
               submission.message.toLowerCase().contains(_searchQuery) ||
               submission.feedbackType.toLowerCase().contains(_searchQuery);
      }).toList();
    }

    // Apply status filter
    if (_selectedStatus != null) {
      filtered = filtered.where((submission) => submission.status == _selectedStatus).toList();
    }

    // Apply type filter
    if (_selectedType != null) {
      filtered = filtered.where((submission) => submission.feedbackType == _selectedType).toList();
    }

    return filtered;
  }

  void clearFilters() {
    _searchQuery = '';
    _selectedStatus = null;
    _selectedType = null;
    notifyListeners();
  }

  // Get statistics
  Map<String, int> getSubmissionStatistics() {
    final stats = <String, int>{};
    
    for (final status in FeedbackStatus.values) {
      stats[status.toString().split('.').last] = 
          _submissions.where((submission) => submission.status == status).length;
    }
    
    return stats;
  }

  // Get average rating
  double getAverageRating() {
    if (_submissions.isEmpty) return 0.0;
    final totalRating = _submissions.fold(0, (sum, submission) => sum + submission.rating);
    return totalRating / _submissions.length;
  }

  // Get recent submissions (last 7 days)
  List<FeedbackSubmission> getRecentSubmissions() {
    final sevenDaysAgo = DateTime.now().subtract(const Duration(days: 7));
    return _submissions.where((submission) => submission.submittedAt.isAfter(sevenDaysAgo)).toList();
  }

  // Get submissions by rating
  List<FeedbackSubmission> getSubmissionsByRating(int rating) {
    return _submissions.where((submission) => submission.rating == rating).toList();
  }
}
